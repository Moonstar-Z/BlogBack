---
title: C++11/右值应用
tag: Cpp
categories: 技术
---

## 左右和右值

***

我们先简单的理解一下什么是左值和右值

- 左值是可以位于赋值运算符 `=` 左侧的表达式(当然，左值也可以位于 `=` 的右侧)。

- 右值是不可以位于 `=` 左侧的表达式。

我们可以用下面的代码进行简单的解释

<!--more-->

```C++
int foo(10);
int bar(20);

foo = bar;
bar = foo;
foo = foo * bar;

int baz;
baz = foo * bar;		// OK right value =  foo * bar
foo * bar = 30;    	// Error
```

但是在C++里面有新的定义

> 一个表达式是左值还是右值，取决于我们使用的是它的值还是它在内存中的位置(作为对象的身份)。也就是说一个表达式具体是左值还是右值，需要在实际的语义。

因此我们可以得出下面的特性：

- 在多数情况下，需要右值的地方可以被左值代替，但是在需要左值的地方我们不能使用右值代替。
- 左值存放在对象中，有持久的状态；右值要不是字面常量，要不就在表达式中创建的临时对象。(按参数传递，返回值等等)，没有持久状态。



## 左值引用和右值引用

---

在C++既然存在左值和右值，那就也就存在左值引用和右值引用。



左值引用是常见的引用，所以一般在提到「对象的引用」的时候，指得就是左值引用。如果我们将一个对象的内存空间绑定到另一个变量上，那么这个变量就是左值引用。在建立引用的时候，我们是「将内存空间绑定」，因此我们使用的是一个对象在内存中的位置，这是一个左值。因此，我们不能将一个右值绑定到左值引用上。另一方面，由于<font color = 'red'>常量左值引用</font>保证了我们不能通过引用改变对应内存空间的值，因此我们可以将右值绑定在常量引用上。

```C++
int foo = 10;

int &bar = foo;  			//OK   : left value 
int &baz = 42;   			//Error: 42 is right value can not bind in left value reference
const int& bab = 43;	//OK   : 42 is right value, but bab is a const left value that complier can make place
```

`the right value refernece is also a refernece,but it just can bind in right value`

```C++
int foo = 10;

int &bar  = foo;
int &&baz = foo;     // Err: foo is left value, but baz is a right value reference
int &&baa = 32; 
int &&bav = foo * 1;  // OK:
int &bau  = foo++;	  // Err: 后置自增运算符返回的是右值 不能绑定在左值应用上
const int& bai = foo+;// OK :
int &&baw = foo-;			// OK : 

```

`as all, we can get this:`

- 右值引用的对象，是临时的，即将被销毁的。
- 右值引用的对象，不会在其他地方使用。(临时、即将被销毁)。



## 引用叠加

---

在modern C++中说明了以下引用叠加推导规则：

```C++
  Type& &   -> Type&
  Type& &&  -> Type&
  Type&& &  -> Type&
  Type&& && -> Type&&
```

我们可以将应用叠加的规则，使用到模版参数的推导中

```C++
template<typename T> void func(T && foo)
auto fp = func<int &&>
```

`func`是一个模版函数，`fp`是一个函数指针，所以如果需要确定`fp`的类型，我们需要确定模版函数参数的类型。

- 在模版中，`T`被 `int&&` 替换，因此`T`是`int`的右值引用；
- 在函数的参数列表声明中，`foo`是`int&&`类型，因此时`int&& &&`类型，根据叠加规则，实际上`foo`的类型是`int&&`类型。

所以我们可以退出`fp`的类型 `void(*)(int &&)` 类型的指针了。



## 右值引用使用

###### `move`语义推导

```C++
#include<iostream>
#include<string>

class Container
{
public:
  Container()
  {
    resource_ = new string();
    std::cout << "default constructor." << std::endl;
  }
  explicit Container(const std::string & resource)
  {
    resource_ = new std::string(resource);
    std::cout << "explicit constructor." << std::endl;
  }
  ~Container()
  {
    delete resource_;
    std::cout << "destructor " << std::endl;
  }
  Container(const Container& rhs)
  {
    resource_ = new std::string(*(rhs.resource_));
    std::cout << "copy constructor." << std::endl;
  }
  Container &operator=(const Container& rhs)
  {
    delete resource_;
    resource_ =  new std::string(*(rhs.resource_));
    std::cout << "copy assignmemt." << std::endl;
    return *this;
  }
private:
  std::string *resource_ = nullptr;
}
```

对于上面的类，因为是**深拷贝**的原因，所以在一些赋值操作上效率会很低，`operato=` 这个需要先`delete`，然后在进行操作。

```C++
Container get()
{
  Container ret("tag");
  return ret;
}

int main()
{
  Container foo;
  // .... 
  foo = get();
  return 0;
}
```

我们可以预测到早使用`foo = get()`的时候，整个类的会发生以下事情。 

- `get()`函数会一个临时`Container`对象。
- 销毁`foo`中资源。`delete resource_`。
- 将`rhs`中的资源拷贝一份，同时赋值给`foo`的`resource_`;
- 销毁`rhs`这个临时对象。

实际上，销毁foo中的存在的对象，然后再从临时对象中复制相应的资源，这件事是不是可以进行优化。直接将foo中的资源抛弃后接管get()返回的临时对象。这就是move语义，减少了中间一些步骤。提升效率。相当于我们在使用operator操作的是这样子的赋值函数。

```C++
Container & Container::operator=(<mystery type> rhs)
```

同时我们的拷贝的赋值运算符还是急需要保留的，我们希望当Container::operator=的右操作数是右值引用时，调用这个版本的赋值运算符。

```C++
#include"Container.h"

///move构造函数 
Container(Container&& rhs) : resource_(rhs.resource_)
{
  rhs.resource_ = nullptr;
  std::cout << "move constructor." << std::endl;
}

///针对move语义编写operator=函数
Container &operator=(Container && rhs)
{
 	std::string *temp = resource_;
  resource_ = rhs.resource_;
  rhs.resource_ = temp;
  std::cout << "move assignment." << std::endl;
  return *this;
}
```

## 完美转发

我们先看一个工厂函数

```cpp
template<typename T, typename ArgT>
std::shared_ptr<T> factory(const ArgT & arg)
{
  return shared_ptr<T>(new T(arg));
}
```

factory函数有两个模板参数T和ArgT，并假定类型T有一个构造函数，可以接受 const ArgT&的类型参数，进行T类型对象的构造，然后返回一个T类型的只能指针，指向一个构造出来的对象。

此处的factor是可以接受右值(允许将右值丙丁在常量左值引用上)|左值的。但是有一个我们之前分析过的问题，不管arg是什么类型，到函数内部后，<font color = "red">arg本身都是一个左值</font>。所以此时加入T的构造函数支持移动构造函数，也没有使用的机会，将永远不会被调用。也就是说factory函数没有有办法实现move语义。并不是完美转发。

我们这里引入一个函数，它是标准库的一部分：

```C++
template<class S>
S && forward(typename std::remove_reference<S>::type& a) noexcept
{
  return static_cast<S&&>(a);
}
```

当`a`的类型是`S&`的时候，函数将返回`S&`；当a的类型是`S&&`的时候，函数将返回`S&&`。因此，在这种情况下，我们只需要稍微改动工厂函数的定义就可以了。



