---
title: C++11-右值应用
tag: CPP
categories: 技术
---

#### <center>右值引用</center>

#### 左右和右值

---

我们先简单的理解一下什么是左值和右值

- 左值是可以位于赋值运算符 `=` 左侧的表达式(当然，左值也可以位于 `=` 的右侧)。

- 右值是不可以位于 `=` 左侧的表达式。

我们可以用下面的代码进行简单的解释

```C++
int foo(10);
int bar(20);

foo = bar;
bar = foo;
foo = foo * bar;

int baz;
baz = foo * bar;		// OK right value =  foo * bar
foo * bar = 30;    	// Error
```

但是在C++里面有新的定义

> 一个表达式是左值还是右值，取决于我们使用的是它的值还是它在内存中的位置(作为对象的身份)。也就是说一个表达式具体是左值还是右值，需要在实际的语义。

因此我们可以得出下面的特性：

- 在多数情况下，需要右值的地方可以被左值代替，但是在需要左值的地方我们不能使用右值代替。
- 左值存放在对象中，有持久的状态；右值要不是字面常量，要不就在表达式中创建的临时对象。(按参数传递，返回值等等)，没有持久状态。

#### <font color= 'red'>左值引用和右值引用</font>

在C++既然存在左值和右值，那就也就存在左值引用和右值引用。



左值引用是常见的引用，所以一般在提到「对象的引用」的时候，指得就是左值引用。如果我们将一个对象的内存空间绑定到另一个变量上，那么这个变量就是左值引用。在建立引用的时候，我们是「将内存空间绑定」，因此我们使用的是一个对象在内存中的位置，这是一个左值。因此，我们不能将一个右值绑定到左值引用上。另一方面，由于<font color = 'red'>常量左值引用</font>保证了我们不能通过引用改变对应内存空间的值，因此我们可以将右值绑定在常量引用上。

```C++
int foo = 10;

int &bar = foo;  			//OK   : left value 
int &baz = 42;   			//Error: 42 is right value can not bind in left value reference
const int& bab = 43;	//OK   : 42 is right value, but bab is a const left value that complier can make place
```

`the right value refernece is also a refernece,but it just can bind in right value`

```C++
int foo = 10;

int &bar  = foo;
int &&baz = foo;     // Err: foo is left value, but baz is a right value reference
int &&baa = 32; 
int &&bav = foo * 1;  // OK:
int &bau  = foo++;	  // Err: 后置自增运算符返回的是右值 不能绑定在左值应用上
const int& bai = foo+;// OK :
int &&baw = foo-;			// OK : 

```

`as all, we can get this:`

- 右值引用的对象，是临时的，即将被销毁的。
- 右值引用的对象，不会在其他地方使用。(临时、即将被销毁)。

#### 引用叠加

在modern C++中说明了以下引用叠加推导规则：

```C++
	Type& &   -> Type&
  Type& &&  -> Type&
  Type&& &  -> Type&
  Type&& && -> Type&&
```

我们可以将应用叠加的规则，使用到模版参数的推导中

```C++
template<typename T> void func(T && foo)
auto fp = func<int &&>
```

`func`是一个模版函数，`fp`是一个函数指针，所以如果需要确定`fp`的类型，我们需要确定模版函数参数的类型。

- 在模版中，`T`被 `int&&` 替换，因此`T`是`int`的右值引用；
- 在函数的参数列表声明中，`foo`是`int&&`类型，因此时`int&& &&`类型，根据叠加规则，实际上`foo`的类型是`int&&`类型。
