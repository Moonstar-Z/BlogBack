---
title: C++11/右值应用
tag: Cpp
categories: 技术
---



## 左右和右值

***

我们先简单的理解一下什么是左值和右值

- 左值是可以位于赋值运算符 `=` 左侧的表达式(当然，左值也可以位于 `=` 的右侧)。

- 右值是不可以位于 `=` 左侧的表达式。

我们可以用下面的代码进行简单的解释

<!--more-->

```C++
int foo(10);
int bar(20);

foo = bar;
bar = foo;
foo = foo * bar;

int baz;
baz = foo * bar;		// OK right value =  foo * bar
foo * bar = 30;    	// Error
```

但是在C++里面有新的定义

> 一个表达式是左值还是右值，取决于我们使用的是它的值还是它在内存中的位置(作为对象的身份)。也就是说一个表达式具体是左值还是右值，需要在实际的语义。

因此我们可以得出下面的特性：

- 在多数情况下，需要右值的地方可以被左值代替，但是在需要左值的地方我们不能使用右值代替。
- 左值存放在对象中，有持久的状态；右值要不是字面常量，要不就在表达式中创建的临时对象。(按参数传递，返回值等等)，没有持久状态。



## 左值引用和右值引用

---

在C++既然存在左值和右值，那就也就存在左值引用和右值引用。



左值引用是常见的引用，所以一般在提到「对象的引用」的时候，指得就是左值引用。如果我们将一个对象的内存空间绑定到另一个变量上，那么这个变量就是左值引用。在建立引用的时候，我们是「将内存空间绑定」，因此我们使用的是一个对象在内存中的位置，这是一个左值。因此，我们不能将一个右值绑定到左值引用上。另一方面，由于<font color = 'red'>常量左值引用</font>保证了我们不能通过引用改变对应内存空间的值，因此我们可以将右值绑定在常量引用上。

```C++
int foo = 10;

int &bar = foo;  			//OK   : left value 
int &baz = 42;   			//Error: 42 is right value can not bind in left value reference
const int& bab = 43;	//OK   : 42 is right value, but bab is a const left value that complier can make place
```

`the right value refernece is also a refernece,but it just can bind in right value`

```C++
int foo = 10;

int &bar  = foo;
int &&baz = foo;     // Err: foo is left value, but baz is a right value reference
int &&baa = 32; 
int &&bav = foo * 1;  // OK:
int &bau  = foo++;	  // Err: 后置自增运算符返回的是右值 不能绑定在左值应用上
const int& bai = foo+;// OK :
int &&baw = foo-;			// OK : 

```

`as all, we can get this:`

- 右值引用的对象，是临时的，即将被销毁的。
- 右值引用的对象，不会在其他地方使用。(临时、即将被销毁)。



## 引用叠加

---

在modern C++中说明了以下引用叠加推导规则：

```C++
  Type& &   -> Type&
  Type& &&  -> Type&
  Type&& &  -> Type&
  Type&& && -> Type&&
```

我们可以将应用叠加的规则，使用到模版参数的推导中

```C++
template<typename T> void func(T && foo)
auto fp = func<int &&>
```

`func`是一个模版函数，`fp`是一个函数指针，所以如果需要确定`fp`的类型，我们需要确定模版函数参数的类型。

- 在模版中，`T`被 `int&&` 替换，因此`T`是`int`的右值引用；
- 在函数的参数列表声明中，`foo`是`int&&`类型，因此时`int&& &&`类型，根据叠加规则，实际上`foo`的类型是`int&&`类型。

所以我们可以退出`fp`的类型 `void(*)(int &&)` 类型的指针了。



## 右值引用使用



我们看一下段代码：

```c++
#include<iostream>
using namespace std;

class HasPtrMem
{
  public:
  	HasPtrMem():d(new int(0)) { cout << "Constrcut: " << ++n_cstr << endl;}
  	HasPtrMem(const HasPtrMem & h):d(new int(h*.d)) {cout << "copy constrct: " ++n_cptr <<end;}
  	~HasPtrMem() { cout << "Destruct :" <<++n_dptr << endl;}
  
  	int *d;
  	static int n_cstr;
  	static int n_cptr;
  	static int n_dstr;
};
	int HasPtrMem::n_cstr = 0;
	int HasPtrMem::n_cptr = 0;
	int HasPtrMem::n_dstr = 0;

	HasPtrMem GetTemp() {return HasPtrMem(); }

	int main()
  {
    	HasPtrMem a = GetTemp();
  }
```



###### `move`语义推导

```C++
#include<iostream>
#include<string>

class Container
{
public:
  Container()
  {
    resource_ = new string();
    std::cout << "default constructor." << std::endl;
  }
  explicit Container(const std::string & resource)
  {
    resource_ = new std::string(resource);
    std::cout << "explicit constructor." << std::endl;
  }
  ~Container()
  {
    delete resource_;
    std::cout << "destructor " << std::endl;
  }
  Container(const Container& rhs)
  {
    resource_ = new std::string(*(rhs.resource_));
    std::cout << "copy constructor." << std::endl;
  }
  Container &operator=(const Container& rhs)
  {
    delete resource_;
    resource_ =  new std::string(*(rhs.resource_));
    std::cout << "copy assignmemt." << std::endl;
    return *this;
  }
private:
  std::string *resource_ = nullptr;
}
```

对于上面的类，因为是**深拷贝**的原因，所以在一些赋值操作上效率会很低，`operato=` 这个需要先`delete`，然后在进行操作。

```C++
Container get()
{
  Container ret("tag");
  return ret;
}

int main()
{
  Container foo;
  // .... 
  foo = get();
  return 0;
}
```

我们可以预测到早使用`foo = get()`的时候，整个类的会发生以下事情。 

- `get()`函数会一个临时`Container`对象。
- 销毁`foo`中资源。`delete resource_`。
- 将`rhs`中的资源拷贝一份，同时赋值给`foo`的`resource_`;
- 销毁`rhs`这个临时对象。

实际上，销毁foo中的存在的对象，然后再从临时对象中复制相应的资源，这件事是不是可以进行优化。直接将foo中的资源抛弃后接管get()返回的临时对象。这就是move语义，减少了中间一些步骤。提升效率。相当于我们在使用operator操作的是这样子的赋值函数。

```C++
Container & Container::operator=(<mystery type> rhs)
```

同时我们的拷贝的赋值运算符还是急需要保留的，我们希望当`Container::operator=`的右操作数是右值引用时，调用这个版本的赋值运算符。

```C++
#include"Container.h"

///move构造函数 
Container(Container&& rhs) : resource_(rhs.resource_)
{
  rhs.resource_ = nullptr;
  std::cout << "move constructor." << std::endl;
}

///针对move语义编写operator=函数
Container &operator=(Container && rhs)
{
 	std::string *temp = resource_;
  resource_ = rhs.resource_;
  rhs.resource_ = temp;
  std::cout << "move assignment." << std::endl;
  return *this;
}
```

## 完美转发

我们先看一个工厂函数

```cpp
template<typename T, typename ArgT>
std::shared_ptr<T> factory(const ArgT & arg)
{
  return shared_ptr<T>(new T(arg));
}
```

`factory`函数有两个模板参数`T`和`ArgT`，并假定类型`T`有一个构造函数，可以接受` const ArgT&`的类型参数，进行T类型对象的构造，然后返回一个T类型的只能指针，指向一个构造出来的对象。

此处的`factor`是可以接受右值(允许将右值丙丁在常量左值引用上)|左值的。但是有一个我们之前分析过的问题，不管`arg`是什么类型，到函数内部后，<font color = "red">`arg`本身都是一个左值</font>。所以此时加入T的构造函数支持移动构造函数，也没有使用的机会，将永远不会被调用。也就是说`factory`函数没有有办法实现`move`语义。并不是完美转发。

我们这里引入一个函数，它是标准库的一部分：

```C++
template<class S>
S && forward(typename std::remove_reference<S>::type& a) noexcept
{
  return static_cast<S&&>(a);
}
```

当`a`的类型是`S&`的时候，函数将返回`S&`；当a的类型是`S&&`的时候，函数将返回`S&&`。因此，在这种情况下，我们只需要稍微改动工厂函数的定义就可以了。

```c++
template<typename T, typename ArgT>
std::shared_ptr<T> factory(ArgT && arg)
{
  return std::shard_ptr<T>(new T(std::forward<ArgT>(arg)));
}
```

- 当`arg`是接受的参数是`Type&`时，`ArgT`是`Type&`，`arg`的类型是`Type&`，此时`T::T(Type&)`被调用。
- 当`arg`是接受的参数是`Type&&`时，`ArgT`是`Type&&`，`arg`的类型是`Type&&`，此时`T::T(Type&&)`被调用。

此时保留了`move`语义，实现完美转发。

## std::move

标准库还定义了一个`std::move`函数，他的作用是将传入的参数以右值引用的方式返回。

```C++
template <class T>
typename std::remove_reference<T>::type&&
std::move(T&& a)noexcept
{
  typedef typename std::remove_reference<T>::type&& RvalRef;
  return static_cast<RvalRef>(a);
}
```

首先，出现了两次的`std::remove_reference<T>::type&&`, 他能保证不管`T`传入什么值，我们返回的值都是一个真实的右值引用。通过`static_cast<RvalRef>(a)`能将`a`强制转换成右值引用并返回。因此有了`std::move`，我们就可以调用`std::unique_ptr`的移动赋值运算符。

## 移动迭代器

- `move_iterator`迭代移动器，其可以通过移动而不是赋值的方式，将某个区域空间中的元素移动到另一个指定的空间。
- 我们可以通过标准库的`make_move_iterator()`函数将一个普通的迭代器转换成一个移动迭代器。

```c++
class StrVec
{
public:
  	size_t size()const {return first_free - elements; }
  	std::string *begin()const {return elements;}
  	std::string *end()const {return *first_free;}
private:
  	void reallocate();
  	void free();
private:
  	static std::allocator<std::string> alloc;	// 分配器
  	std::string *elements;										// 指向数组首个元素的指针	
  	std::string *first_free;									// 指向数组第一个空闲元素的指针
  	std::string *cap;													// 指向数组尾后位置的指针
}
```

![C++(标准库):28---STL迭代器之（迭代器适配器(插入迭代器、流迭代器、反向迭代器、移动迭代器)）_运算符_25](/Users/insta360/Bolg/BlogBack/source/_posts/Work/C++/右值引用_1.png)

我们详细注意一个`reallocate()`成员函数

- 该函数的功能是分配更多的内存，并将原来的元素都移动到新内存中。
- 由于移动迭代器同样也支持正常的迭代器操作，所以我们可以将一对移动迭代器传递给算法。
- 其中我们使用一个名为`uninitialized_copy()`的算法：
  - 算法对参数1和参数2所指的输入序列中的每个元素调用`construct`拷贝到从`first`开始的对应的位置上去。
  - 此算法使用迭代器的解引用运算符从输入序列中提取元素，但是此时我们使用`make_move_iterator`将其迭代器类型改为移动迭代器，因为解引用运算符生成的是一个右值引用，这意味这`construct`会使用移动构造函数来移动元素，从而避免了元素的拷贝。

```c++
void StrVec::reallocate()
{
  	auto newCapacity = size() ? 2*size() : 1;
  	auto first = alloc.allocate(newCapacity);
  	
  	auto last = uninitialized_copy(make_move_iterator(begin()),
                                   make_move_iterator(end()),
                                   first);
  
  	free()
    elements   = first;
  	first_free = last;
  	cap = elements + newCapacity;
}
```



​	由于我们在移动一个对象后具有不确定的状态，对齐调用`std::move`是危险的。当我们调用`move`时，必须绝对确认移动源对象后没有其他的使用。通过在类代码中使用`std::move`我们可以大幅度的提高一些大量使用拷贝操作的性能。但是在普通的逻辑程序中使用`std::move`会导致很多某明其妙的问题。











